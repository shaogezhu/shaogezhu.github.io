title: JVM垃圾回收-记忆集和卡表
date: 2022-03-06 00:23:23
update: 2022-03-06
categories:

- [Java, 学习笔记]
tags:
- JVM
- java
- 垃圾回收

---



:::info

JVM垃圾回收系列（一）：记忆集和卡表

:::





🥂在说记忆集和卡表之前，先给大家介绍一下**跨代引用**的问题。

![image](/assets/2022-3/jvm1.png)

🏫假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代的实例对象1在老年代中被引用，为了找出该区域(新生代)中所有的存活对象，不得不在固定的GC Roots之外，再**额外遍历整个老年代**中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。

👉🏻事实上并不只是新生代、老年代之间才有**跨代引用**的问题，所有涉及部分区域收集（Partial GC)行为的垃圾收集器，典型的如[**G1**]{.blue}、[**ZGC**]{.blue}和[**Shenandoah**]{.blue}收集器，都会面临相同的问题。


## 那么如何才能解决跨代引用呢？


首先，**跨代引用相对于同代引用来说仅占极少数**。原因是跨代引用的对象应该倾向于同时生存或者同时死亡的（举个🌰：如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了）。



🌴🌴依据上面说所，就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为 **“记忆集”** ，Remembered Set)， **这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。** 此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

下面就来介绍一下这个全局的数据结构记忆集。



## 记忆集

✨记忆集是一种用于记录从[**非收集区域**]{.blue}指向[**收集区域**]{.pink}的指针集合的[**抽象**]{.red}数据结构。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构，如下面代码所示:
```java
//以对象指针来实现记忆集的伪代码
Class RememberedSet {
	Object[] set[OBJECT_INTERGENERATIONAL_REFERENCE_SIZE]; 
}
```
🎈这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾收集的场景中，**收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了**，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本。下面列举了一些可供选择（当然也可以选择这个范围以外的）的记录精度：

- **字长精度：** 每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
- **对象精度：** 每个记录精确到一个对象，该对象里有字段含有跨代指针。
- **卡精度：** 每个记录精确到一块内存区域，该区域内有对象含有跨代指针。


🍍🍍上面的，第三种“卡精度”所指的是用一种称为**“卡表”(Card Table)**的方式去实现记忆集，这也是目前最常用的记忆集的实现形式。


### 卡表和记忆集又有什么关系呢？
👀前面介绍记忆集的时候提到 记忆集其实是一种[**"抽象”**]{.red}的数据结构，抽象的意思是[只定义了记忆集的行为意图，并没有定义其行为的具体实现]{.orange}。**[卡表]{.blue}就是记忆集的一种具体实现**，它定义了记忆集的记录精度、与堆内存的映射关系等。关于记忆集与卡表的关系，可以按照Java中Map与HashMap的关系来类比理解（即接口和实现类来的关系）。

🍋下面来详细说一下记忆集的具体实现卡表


## 卡表

✨卡表是使用一个**字节数组CARD_TABLE[] **实现，每个元素对应其标识的内存区域一块特定大小的内存块，每个内存块称为卡页，hotspot使用的卡页是2^9大小 即512字节。如下图所示

![image](/assets/2022-3/jvm2.png)

🍦这样我们就可以把某个区域按照卡页进行划分，假如我们现在要对新生代区域进行垃圾回收，那么就可以把老年代区域看成是一个卡页一个卡页划分好的，如下图所示。

![image](/assets/2022-3/jvm3.png)

如图所示🍹，因为cardpage1中存在指向新生代的跨代引用，所以对应卡表的第一个位置为1，表明该page区域存在跨代应用的对象。

**📍卡表角度：** 因为page1中存在跨代饮用的对象，所以卡表对应的第一个位置记为1，表明page1这个元素变脏。

**📍内存回收角度：** 因为卡表的第一个位置为1，表明该page区域存在跨代应用的对象，垃圾回收的时候需要扫描该区域。

😎一个卡页的内存中通常包含不止一个对象，只要卡页内有一个(或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个[元素变脏（Dirty)]{.purple}，没有则标识为0。在垃圾收集发生时，**只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。**这样就不需要扫描整个老年代大大减少GC Roots的扫描范围。



 🚀🚀🚀
 <br>